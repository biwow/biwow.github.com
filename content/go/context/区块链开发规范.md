**目录**

[TOC]

# 一、 编程规约
## （一） 命名风格


1.【推荐】需要注释来补充的命名就不算是好命名。

说明：命名应该做到让人见名知意，好的命名可以让人节省关注注释的时间。

2.【强制】使用可搜索的名称

说明：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。

3.【推荐】做有意义的区分  

说明：要区分名称，就要以读者能鉴别不同之处的方式来区分   

比如说Product 和 ProductInfo 和 ProductData 没有区别，NameString 和 Name 没有区别。

错误示例：

```
　type Reader interface {
        Read(p []byte) (n int, err error)
　　}

　　// 多个函数接口
　　type WriteFlusher interface {
    　　Write([]byte) (int, error)
    　　Flush() error
　　}
```
4.【强制】目录名必须为全小写单词，允许加中划线‘-’组合方式，但是头尾不能为中划线。

例如：

```
go-sql-driver
hsa-microservice
service-mgr
```
5.【推荐】目录名虽然允许出现中划线，但是尽量避免或少加中划线。


6.【推荐】取名尽量采取有意义的包名，简单和可阅读。

7.【强制】包名必须全部为小写单词，无下划线，越短越好。尽量不要与标准库重名。

错误示例：

```
import (

    "MyUtil"                //包名大写          

	"suffix_array"          //有下划线
	
	"io/util suffixarray"   //不仅长，还是个带空格的包名
	
	"io/ioutil"             //与标准库重名
	
)
```

说明：包名在被导入后，会以 package.Func()方式使用，任何人使用你的包都得敲一遍该包名,因为包名也是类型和函数的一部分

例如`buf := new(bytes.Buffer)`就不要取名为 `bytes.BytesBuffer`，这样过于累赘。


8.【强制】禁止通过中划线连接多个单词的方式来命名包名。
```
package go-oci8 //编译错误
```
9.【推荐】包名尽量与所在目录名一致，引用时比较方便。  

说明：这是因为在import导入的包是按目录名来命名的，如果不一致，代码阅读者就很困惑。

10.【强制】文件名必须为小写单词，允许加下划线‘_’组合方式，但是头尾不能为下划线。

例如: port_allocator.go

11.【推荐】文件名虽然允许出现下划线，但是尽量避免。

说明：如果采用下划线的方式，注意避免跟下面保留特定用法的后缀冲突：   
1）测试文件：_test.go  
2）系统相关的文件：  

```
_386.go、_amd64.go、_arm.go、_arm64.go、_android.go、_darwin.go、_dragonfly.go、_freebsd.go、_linux.go、_nacl.go、_netbsd.go、_openbsd.go、_plan9.go、_solaris.go、_windows.go、_android_386.go、_android_amd64.go、_android_arm.go、_android_arm64.go、_darwin_386.go、_darwin_amd64.go、_darwin_arm.go、_darwin_arm64.go、_dragonfly_amd64.go、_freebsd_386.go、_freebsd_amd64.go、_freebsd_arm.go、_linux_386.go、_linux_amd64.go、_linux_arm.go、_linux_arm64.go、_linux_mips64.go、_linux_mips64le.go、_linux_ppc64.go、_linux_ppc64le.go、_linux_s390x.go、_nacl_386.go、_nacl_amd64p32.go、_nacl_arm.go、_netbsd_386.go、_netbsd_amd64.go、_netbsd_arm.go、_openbsd_386.go、_openbsd_amd64.go、_openbsd_arm.go、_plan9_386.go、_plan9_amd64.go、_plan9_arm.go、_solaris_amd64.go、_windows_386.go
_windows_amd64.go
```

12.【推荐】文件名以功能为指引，名字中不需再出现模块名或者组件名。

说明：因为Go包的导入是与路径有关的，本身已经隐含了模块/组件信息。



13.【强制】变量命名基本上遵循相应的英文表达或简写，在相对简单的环境（对象数量少、针对性强）中，可以将一些名称由完整单词简写为单个字母

例如：

* user 可以简写为 u
* userID 可以简写 uid
* 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：

```
　　var isExist bool
　　var hasConflict bool
　　var canManage bool
　　var allowGitHook bool
　　
```

只有从其他标准移植过来的常量才和原来保持一致，比如：  

* 自定义的 http.StatusOK  

* 移植过来的 tls.TLS_RSA_WITH_AES_128_CBC_SHA


14.【强制】变量名称一般遵循驼峰法，并且不允许出现下划线，当遇到特有名词时，需要遵循以下规则：

* 如果变量为私有，且特有名词为首个单词，则使用小写，如：apiClient
* 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID

错误示例：UrlArray，应该写成 urlArray 或者 URLArray

下面列举了一些常见的特有名词：

```
"API"，"ASCII"，"CPU"，"CSS"，"DNS"，"EOF"，GUID"，"HTML"，"HTTP"，"HTTPS"，"ID","IP"，"JSON"，"LHS"，"QPS"，"RAM"，"RHS"
　　"RPC", "SLA"，"SMTP"，"SSH"，"TLS"，"TTL","UI"，"UID"，"UUID"，"URI"，"URL"， "UTF8"，"VM"，"XML"，"XSRF"，"XSS"
```

15.【强制】不要使用_来命名变量名，多个变量申明放在一起  

正确示例：

```
var (
    Found bool
    count int
)
```
16.【强制】在函数外部申明必须使用var,不要采用:=，容易踩到变量的作用域的问题。

17.【强制】全局变量必须为大小写混排的驼峰模式，不允许出现下划线。首字母根据作为范围确定大小写。

例如:

```
	var Global int //包外
	var global int //包内
```


18.【推荐】尽量避免跨package使用全局变量，尽量减少全局变量的使用。


19.【强制】局部变量名必须为大小写混排，且首字母小写，不能有下划线。
例如:

```
	result, err := MakeRegexpArray(str)
```


20.【推荐】for循环变量可以使用单字母。

21.【强制】struct申明和初始化格式采用多行

定义如下：

```
type User struct{
    Username  string
    Email     string
}
```
初始化如下：

```
u := User{
    Username: "astaxie",
    Email:    "astaxie@gmail.com",
}
```

22.【强制】结构体名必须为大小写混排的驼峰模式，不允许出现下划线，可被包外部引用则首字母大写；如仅包内使用，则首字母小写。

例如:

```
	type ServicePlan struct 
	type internalBroker struct
```

23.【推荐】结构名建议采用名词、动名词为好。

结构体名应该是名词或名词短语，如Custome、WikiPage、Account、AddressParser，避免使用 Manager、Processor、Data、Info、这样的类名，类名不应当是动词。


24.【强制】接口名必须为大小写混排，支持包外引用则首字母大写，仅包内使用则首字母小写。不能有下划线，整体必须为名词。

25.【推荐】单个函数的接口名以”er”作为后缀。

单个函数的接口名以”er”作为后缀，如Reader,Writer。接口的实现则去掉“er”。除非有更合适的单词。  

例如：

```
	type Reader interface {...}
```

26.【强制】函数名必须为大小写混排的驼峰模式

函数名必须为大小写混排的驼峰模式，名字可以长但是得把功能，必要的参数描述清楚，不允许出现下划线。

示例:
```
func MakeRegexpArrayOrDie     // 暴露给包外部函数

func matchesRegexp            // 包内部函数
```

27.【推荐】函数名力求精简准确，并采用用动词或动词短  

如 postPayment、deletePage、save。并依 Javabean 标准加上 get、set、is前缀。

例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..


28.【强制】返回值如果是命名的，则必须大小写混排，首字母小写。

29.【推荐】 函数的返回值应避免使用命名的参数。

举例：

```
	func (n *Node) Bad() (node *Node, err error)
	func (n *Node) Good() (*Node, error)
```

因为如果使用命名变量很容易导致临时变量覆盖而引起隐藏的bug。


例外情况：多个返回值类型相同的情况下，使用命名返回值来区分不同的返回参数。

说明：命名返回值使代码更清晰，同时更加容易读懂。

举例：

```
func getName()(firstName, lastName, nickName string){
    firstName = "May"
    lastName = "Chen"
    nickName = "Babe"
    return
}
```



## （二） 常量定义

1.【强制】常量&枚举名采用大小写混排的驼峰模式（Golang官方要求），不允许出现下划线

示例：

```
	const (
	    CategoryBooks    = iota // 0
	    CategoryHealth          // 1
	    CategoryClothing        // 2
	)
```


2.【推荐】按照功能来区分，而不是将所有类型都分在一组，并建议将公共常量置于私有常量之前

示例：

```
	const (
	    KindPage = "page"
	
	    // The rest are node types; home page, sections etc.
	    KindHome         = "home"
	    KindSection      = "section"
	    KindTaxonomy     = "taxonomy"
	    KindTaxonomyTerm = "taxonomyTerm"
	
	    // Temporary state.
	    kindUnknown = "unknown"
	
	    // The following are (currently) temporary nodes,
	    // i.e. nodes we create just to render in isolation.
	    kindRSS       = "RSS"
	    kindSitemap   = "sitemap"
	    kindRobotsTXT = "robotsTXT"
	    kind404       = "404"
	)
```



3.【强制】如果是枚举类型的常量，需要先创建相应类型

示例：

```
	type tstCompareType int
	
	const (
	    tstEq tstCompareType = iota
	    tstNe
	    tstGt
	    tstGe
	    tstLt
	    tstLe
	)
```



4.【推荐】如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀

示例：

```
	type PullRequestStatus int
	
	const (
	    PullRequestStatusConflict PullRequestStatus = iota
	    PullRequestStatusChecking
	    PullRequestStatusMergeable
	)
```

5.【推荐】 为整数常量添加 String() 方法

如果你利用 iota 来使用自定义的整数枚举类型，务必要为其添加 String() 方法。例如，像这样：

```
type State int

const
(

    Running State = iota

    Stopped

    Rebooting

    Terminated

)
```
如果你创建了这个类型的一个变量，然后输出，会得到一个整数：

```
func main() {

    state := Running

    // print: "state 0"

    fmt.Println("state ", state)

}

```
除非你回顾常量定义，否则这里的0看起来毫无意义。只需要为State类型添加String()方法就可以修复这个问题：

```
func (s State) String() string {

    switchs {

    caseRunning:

        return"Running"

    caseStopped:

        return"Stopped"

    caseRebooting:

        return"Rebooting"

    caseTerminated:

        return"Terminated"

    default:

        return"Unknown"
        
    }

}
```
新的输出是：state: Running。显然现在看起来可读性好了很多。在你调试程序的时候，这会带来更多的便利。同时还可以在实现  MarshalJSON()、UnmarshalJSON() 这类方法的时候使用同样的手段。  

6.【推荐】让 iota 从 a +1 开始增量

在前面的例子中同时也产生了一个我已经遇到过许多次的 bug。假设你有一个新的结构体，有一个State字段：

```
type T struct{

    Name  string

    Port int

    State State
    
}

```
现在如果基于 T 创建一个新的变量，然后输出，你会得到奇怪的结果：


```
func main() {

    t := T{Name:"example", Port: 6666}

    // prints: "t {Name:example Port:6666 State:Running}"

    fmt.Printf("t %+v\n", t)
    
}

```
看到 bug 了吗？`State`字段没有初始化，Go 默认使用对应类型的零值进行填充。由于`State`是一个整数，零值也就是`0`，但在我们的例子中它表示`Running`。

那么如何知道 State 被初始化了？还是它真得是在`Running`模式？没有办法区分它们，那么这就会产生未知的、不可预测的 bug。不过，修复这个很容易，只要让 iota 从 +1 开始：

```
const
(

    Running State = iota + 1

    Stopped

    Rebooting

    Terminated

)
```
现在t变量将默认输出Unknown，不是吗？ :)  ：

```
func main() {

    t := T{Name:"example", Port: 6666}

    // 输出： "t {Name:example Port:6666 State:Unknown}"

    fmt.Printf("t %+v\n", t)

}
```
不过让 iota 从零值开始也是一种解决办法。例如，你可以引入一个新的状态叫做`Unknown`，将其修改为：

```
const
(

    Unknown State = iota

    Running

    Stopped

    Rebooting

    Terminated

)

```

## （三） 代码格式

1.【强制】对于要使用json转换的结构体代码，变量名必须为大写，否则你只会得到一个为空的对象
例如：

```
	BaiduNewsItem struct {
		Title       string `xml:"title"`
		Link        string `xml:"link"`
		Description string `xml:"description"`
		PubDate     string `xml:"pubDate"`
		Author      string `xml:"author"`
	}
```

2.【强制】运算符前后、逗号后面、if后面等需有单空格隔开。

```
if err != nil {…}
c := a + b
return {}, err
```

例外情况：
go fmt认为应该删除空格的场景。例如，在传参时，字符串拼接的”+”号。


3.【推荐】参数按逻辑紧密程度安排位置, 同种类型的参数放在相邻位置。  

举例：
```
	func(m1, m2 *MenuEntry) bool
	func (c *Client) Delete(key string, recursive bool, dir bool) (*RawResponse, error)
```


4.【强制】相对独立的程序块之间、变量说明之后必须加空行，而逻辑紧密相关的代码则放在一起。


不好的例子：

```
func formatResponseBody(res *http.Response, httpreq *httplib.BeegoHttpRequest, pretty bool) string {
    body, err := httpreq.Bytes()
    if err != nil {
        log.Fatalln("can't get the url", err)
    }
    match, err := regexp.MatchString(contentJsonRegex, res.Header.Get("Content-Type"))
    if err != nil {
        log.Fatalln("failed to compile regex", err)
    }
    if pretty && match {
        var output bytes.Buffer
        err := json.Indent(&output, body, "", "  ")
        if err != nil {
            log.Fatal("Response Json Indent: ", err)
        }
        return output.String()
    }
    return string(body)
}
```

应该改为：

```
func formatResponseBody(res *http.Response, httpreq *httplib.BeegoHttpRequest, pretty bool) string {
    body, err := httpreq.Bytes()
    if err != nil {
        log.Fatalln("can't get the url", err)
    }

    match, err := regexp.MatchString(contentJsonRegex, res.Header.Get("Content-Type"))
    if err != nil {
        log.Fatalln("failed to compile regex", err)
    }

    if pretty && match {
        var output bytes.Buffer
        err := json.Indent(&output, body, "", "  ")
        if err != nil {
            log.Fatal("Response Json Indent: ", err)
        }

        return output.String()
    }

    return string(body)
}
```

提示：当你需要为接下来的代码增加注释的时候，说明该考虑加一行空行了。


5.【推荐】长句子打印或者调用，使用参数进行格式化分行

我们在调用`fmt.Sprint`或者`log.Sprint`之类的函数时，有时候会遇到很长的句子，我们需要在参数调用处进行多行分割：

下面是错误的方式：

```
log.Printf(“A long format string: %s %d %d %s”, myStringParameter, len(a),
    expected.Size, defrobnicate(“Anotherlongstringparameter”,
        expected.Growth.Nanoseconds() /1e6))
```
应该是如下的方式：

```
log.Printf( 
    “A long format string: %s %d %d %s”, 
    myStringParameter,
    len(a),
    expected.Size,
    defrobnicate(
        “Anotherlongstringparameter”,
        expected.Growth.Nanoseconds()/1e6, 
    ),
）  
```
5.【强制】提交代码时，必须使用golint对代码进行检查。  
  
golint 会检测的方面：

* 变量名规范
* 变量的声明，像var str string = "test"，会有警告，应该var str = "test"
* 大小写问题，大写导出包的要有注释
* x += 1 应该 x++

等等
详细可以看官方库示例，https://github.com/golang/lint/tree/master/testdata  

想速成的可以看[Golang lint简易使用方法](http://note.youdao.com/noteshare?id=8d9aa9407360cd4ae7f326057ac183f1&sub=9C9603C030294EC8817C3F6A7F88CAB3)自行学习使用

6.【推荐】提交代码前，必须使用go vet对代码进行检查。

如果说golint是检查我们的代码规范的话，那么vet工具则是可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。

> go get golang.org/x/tools/cmd/vet

使用如下：
> go vet .


7.【推荐】单个文件长度不超过500行。

对开源引入代码可以降低约束，新增代码必须遵循。

8.【推荐】单个函数长度不超过50行。


9.【强制】单个函数圈复杂度最好不要超过10，禁止超过15。

说明：圈复杂度越高，代码越复杂，就越难以测试和维护，同时也说明函数职责不单一。


10.【强制】单行语句不能过长，如不能拆分需要分行写。一行最多120个字符。

换行时有如下建议：
换行时要增加一级缩进，使代码可读性更好；
低优先级操作符处划分新行；换行时操作符应保留在行尾； 
换行时建议一个完整的语句放在一行，不要根据字符数断行


示例：

```
	if ((tempFlag == TestFlag) &&
	(((counterVar - constTestBegin) % constTestModules) >= constTestThreshold)) { 
	    // process code 
	}
```



11.【推荐】函数中缩进嵌套必须小于等于3层。  

举例，禁止出现以下这种锯齿形的函数：

```
	func testUpdateOpts PushUpdateOptions) (err error) {
	    isNewRef := opts.OldCommitID == git.EMPTY_SHA
	    isDelRef := opts.NewCommitID == git.EMPTY_SHA
	    if isNewRef && isDelRef {
	        if isDelRef {
	            repo, err := GetRepositoryByName(owner.ID, opts.RepoName)
	            if err != nil {
	                if strings.HasPrefix(opts.RefFullName, git.TAG_PREFIX) {
	                    if err := CommitRepoAction(CommitRepoActionOptions{
	                        PusherName:  opts.PusherName,
	                        RepoOwnerID: owner.ID,
	                        RepoName:    repo.Name,
	                        RefFullName: opts.RefFullName,
	                        OldCommitID: opts.OldCommitID,
	                        NewCommitID: opts.NewCommitID,
	                        Commits:     &PushCommits{},
	                    }); err != nil {
	                        return fmt.Errorf("CommitRepoAction (tag): %v", err)
	                    }
	                    return nil
	                }
	            }
	            else {
	                owner, err := GetUserByName(opts.RepoUserName)
	                if err != nil {
	                    return fmt.Errorf("GetUserByName: %v", err)
	                }
	
	                return nil
	            }
	        }
	    }
	
	    // other code
	}
```

提示：如果发现锯齿状函数，应通过尽早通过return等方法重构。



## （四） OOP规约

1.【强制】代码中禁止使用魔鬼数字。

错误示例：  
![image](https://upload-images.jianshu.io/upload_images/84735-91e60dc80040e14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

修改后：  
![image](https://upload-images.jianshu.io/upload_images/84735-b4bbdbd3de468c99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

说明：直接使用数字，造成代码难以理解，也难以维护。应采用有意义的静态变量或枚举来代替。

例外情况：有些特殊情况下，如循环或比较时采用数字0，-1，1，这些情况可采用数字。


2.【推荐】 在初始化结构体时使用带有标签的语法

这是一个无标签语法的例子：

```
type T struct{

    Foo string

    Bar int

}


func main() {

    t := T{"example", 123}// 无标签语法

    fmt.Printf("t %+v\n", t)

}
```
那么如果你添加一个新的字段到T结构体，代码会编译失败：

```
type T struct{

    Foo string

    Bar int

    Qux string

}

func main() {

    t := T{"example", 123}// 无法编译

    fmt.Printf("t %+v\n", t)

}
```
如果使用了标签语法，Go的兼容性规则（http://golang.org/doc/go1compat）会处理代码。例如在向net包的类型添加叫做Zone的字段，参见：http://golang.org/doc/go1.1#library。回到我们的例子，使用标签语法：

```
type T struct{

    Foo string

    Bar int

    Qux string

}

func main() {

    t := T{Foo:"example", Bar: 123}

    fmt.Printf("t %+v\n", t)
}
```
这个编译起来没问题，而且弹性也好。不论你如何添加其他字段到T结构体。你的代码总是能编译，并且在以后的 Go 的版本也可以保证这一点。只要在代码集中执行go vet，就可以发现所有的无标签的语法。

3.【推荐】将结构体的初始化拆分到多行

如果有两个以上的字段，那么就用多行。它会让你的代码更加容易阅读，也就是说不要：

```

T{Foo: "example", Bar:someLongVariable, Qux:anotherLongVariable, B: forgetToAddThisToo}
```
而是：


```
T{

    Foo: "example",

    Bar: someLongVariable,

    Qux: anotherLongVariable,

    B: forgetToAddThisToo,

}

```
这有许多好处，首先它容易阅读，其次它使得允许或屏蔽字段初始化变得容易（只要注释或删除它们），最后添加其他字段也更容易（只要添加一行）。



4.【推荐】保持函数内部实现的组织粒度是相近的。

举例，不应该出现如下函数：

```
	func main() {
	    initLog()
	
	    //这一段代码的组织粒度，明显与其他的不均衡
	    orm.DefaultTimeLoc = time.UTC
	    sqlDriver := beego.AppConfig.String("sqldriver")
	    dataSource := beego.AppConfig.String("datasource")
	    modelregister.InitDataBase(sqlDriver, dataSource)
	
	    Run()
	}
```



应该改为：

```
	func main() {
	    initLog()
	
	    initORM()  //修改后，函数的组织粒度保持一致 
	
	    Run()
	}
```

5.【推荐】 返回函数调用

示例：

```

func bar() (string, error) {

    v, err := foo()

    iferr != nil {

        return"", err

    }

    returnv, nil

}

```
然而，你只需要：

```
func bar() (string, error) {

    return foo()

}

```
更简单也更容易阅读（当然，除非你要对某些内部的值做一些记录）。

6.【推荐】 withContext 封装函数  

有时对于函数会有一些重复劳动，例如锁/解锁，初始化一个新的局部上下文，准备初始化变量等等……这里有一个例子：

```
func foo() {

    mu.Lock()

    defer mu.Unlock()

    // foo 相关的工作

}

func bar() {

    mu.Lock()

    defer mu.Unlock()

    // bar 相关的工作
}

func qux() {

    mu.Lock()

    defer mu.Unlock()

    // qux 相关的工作

}
```
如果你想要修改某个内容，你需要对所有的都进行修改。如果它是一个常见的任务，那么最好创建一个叫做withContext的函数。这个函数的输入参数是另一个函数，并用调用者提供的上下文来调用它：

```
func withLockContext(fn func()) {

    mu.Lock

    defer mu.Unlock()

    fn()

}

```
只需要将之前的函数用这个进行封装：

```
func foo() {

    withLockContext(func() {

        // foo 相关工作

    })

}

func bar() {

    withLockContext(func() {

        // bar 相关工作

    })

}

func qux() {

    withLockContext(func() {

        // qux 相关工作

    })

}
```
不要光想着加锁的情形。对此来说最好的用例是数据库链接。现在对 withContext 函数作一些小小的改动：

```
func withDBContext(fn func(db DB)) error {

    // 从连接池获取一个数据库连接

    dbConn := NewDB()

    returnfn(dbConn)

}
```
如你所见，它获取一个连接，然后传递给提供的参数，并且在调用函数的时候返回错误。你需要做的只是：

```
func foo() {

    withDBContext(func(db *DB) error {

        // foo 相关工作

    })

}


func bar() {

    withDBContext(func(db *DB) error {

        // bar 相关工作
        
    })

}


func qux() {

    withDBContext(func(db *DB) error {

        // qux 相关工作

    })

}
```
你在考虑一个不同的场景，例如作一些预初始化？没问题，只需要将它们加到withDBContext就可以了。这对于测试也同样有效。

这个方法有个缺陷，它增加了缩进并且更难阅读。再次提示，永远寻找最简单的解决方案。

7.【推荐】避免使用标识参数来控制函数的执行逻辑。  

举例： 

```
	func doAorB(flag int) {
	    if flag == flagA {
	        processA1()
	        return
	    }
	
	    if flag == flagB {
	        processB1()
	        return
	    }
	}
```

特别是标识为布尔值时，通过标识参数控制函数内的逻辑，true执行这部分逻辑，false执行另外一部分逻辑，说明了函数职责不单一。

8.【推荐】参数嵌套个数不要超过5个

参数过多通常意味着缺少封装，不易维护，容易出错.

9.【推荐】函数返回值个数不要超过3个，如果函数的返回值超过3个，建议将其中关系密切的返回值参数封装成一个结构体。

10.【推荐】禁止出现2处及以上的重复代码。

说明：如果出现，必须抽取为独立小函数。不要担心性能问题，编译器会帮你搞定大部分的内联优化。同时认真阅读第四章节的“代码质量保证优先原则”



## （五） 集合处理	

1.【推荐】把 slice、map 等定义为自定义类型

将 slice 或 map 定义成自定义类型可以让代码维护起来更加容易。假设有一个Server类型和一个返回服务器列表的函数：


```

type Server struct{

    Name string

}

func ListServers() []Server {

    return[]Server{

        {Name:"Server1"},

        {Name:"Server2"},

        {Name:"Foo1"},

        {Name:"Foo2"},

    }

}
```
现在假设需要获取某些特定名字的服务器。需要对 ListServers() 做一些改动，增加筛选条件：

```

// ListServers 返回服务器列表。只会返回包含 name 的服务器。空的 name 将会返回所有服务器。
func ListServers(name string) []Server {

    servers := []Server{

        {Name:"Server1"},

        {Name:"Server2"},

        {Name:"Foo1"},

        {Name:"Foo2"},

    }

    // 返回所有服务器
    if name == ""{

        return servers

    }

    // 返回过滤后的结果
    filtered := make([]Server, 0)

    for_, server := range servers {

        if strings.Contains(server.Name, name) {

            filtered = append(filtered, server)

        }

    }

    return filtered

}
```

现在可以用这个来筛选有字符串Foo的服务器：

```

func main() {

    servers := ListServers("Foo")

    // 输出：“servers [{Name:Foo1} {Name:Foo2}]”

    fmt.Printf("servers %+v\n", servers)

}

```
显然这个函数能够正常工作。不过它的弹性并不好。如果你想对服务器集合引入其他逻辑的话会如何呢？例如检查所有服务器的状态，为每个服务器创建一个数据库记录，用其他字段进行筛选等等……

现在引入一个叫做Servers的新类型，并且修改原始版本的 ListServers() 返回这个新类型：

```
type Servers []Server

// ListServers 返回服务器列表
func ListServers() Servers {

    return[]Server{

        {Name:"Server1"},

        {Name:"Server2"},

        {Name:"Foo1"},

        {Name:"Foo2"},

    }
    
}
```
现在需要做的是只要为Servers类型添加一个新的Filter()方法：

```

// Filter 返回包含 name 的服务器。空的 name 将会返回所有服务器。
func (s Servers) Filter(name string) Servers {

    filtered := make(Servers, 0)

    for_, server := range s {

        ifstrings.Contains(server.Name, name) {

            filtered = append(filtered, server)

        }

    }

    return filtered

}
```
现在可以针对字符串Foo筛选服务器：

```
func main() {

    servers := ListServers()

    servers = servers.Filter("Foo")

    fmt.Printf("servers %+v\n", servers)

}

```

哈！看到你的代码是多么的简单了吗？还想对服务器的状态进行检查？或者为每个服务器添加一条数据库记录？没问题，添加以下新方法即可：

```
func (s Servers) Check()

func (s Servers) AddRecord()

func (s Servers) Len()

...

```

2.【推荐】 为访问 map 增加 setter，getters  

如果你重度使用 map 读写数据，那么就为其添加 getter 和 setter 吧。通过 getter 和 setter 你可以将逻辑封分别装到函数里。这里最常见的错误就是并发访问。如果你在某个 goroutein 里有这样的代码：

```
m["foo"] = bar
```
还有这个：

```
delete(m,"foo")
```
会发生什么？你们中的大多数应当已经非常熟悉这样的竞态了。简单来说这个竞态是由于 map 默认并非线程安全。不过你可以用互斥量来保护它们：

```
mu.Lock()

m["foo"] ="bar"

mu.Unlock()

```

以及：

```

mu.Lock()

delete(m,"foo")

mu.Unlock()

```
假设你在其他地方也使用这个 map。你必须把互斥量放得到处都是！然而通过 getter 和 setter 函数就可以很容易的避免这个问题：

```
func Put(key, value string) {

    mu.Lock()

    m[key] = value

    mu.Unlock()

}

func Delete(key string) {

    mu.Lock()

    delete(m, key)

    mu.Unlock()

}
```
使用接口可以对这一过程做进一步的改进。你可以将实现完全隐藏起来。只使用一个简单的、设计良好的接口，然后让包的用户使用它们：

```

type Storage interface {

    Delete(key string)

    Get(key string) string

    Put(key, value string)

}
```
这只是个例子，不过你应该能体会到。对于底层的实现使用什么都没关系。不光是使用接口本身很简单，而且还解决了暴露内部数据结构带来的大量的问题。

但是得承认，有时只是为了同时对若干个变量加锁就使用接口会有些过分。理解你的程序，并且在你需要的时候使用这些改进。

3.【推荐】 传入的参数是 map，slice，chan 不要传递指针，因为 map，slice，chan 是引用类型，不需要传递指针的指针  


4.【推荐】GO的结构体中控制使用Slice和Map。

GO的slice和map等变量在赋值时，传递的是引用。从结果上看，是浅拷贝，会导致复制前后的两个变量指向同一片数据。这一点和Go的数组、C/C++的数组行为不同，很容易出错。

```
	package main
	import "fmt"
	
	type Student struct {
	    Name     string
	    Subjects []string
	}
	
	func main() {
	    sam := Student{
	        Name: "Sam", Subjects: []string{"Math", "Music"},
	    }
	    clark := sam //clark.Subject和sam.Subject是同一个Slice的引用！
	    clark.Name = "Clark"
	    clark.Subjects[1] = "Philosophy" //sam.Subject[1]也变了！
	    fmt.Printf("Sam : %v\n", sam)
	    fmt.Printf("Clark : %v\n", clark)
	}
	
	执行结果：
	Sam : {Sam [Math Philosophy]}
	Clark : {Clark [Math Philosophy]}
```



作为对比，请看作为Array定义的Subjects的行为：

```
	package main
	import "fmt"
	
	type Student struct {
	    Name     string
	    Subjects [2]string
	}
	
	func main() {
	    var clark Student
	    sam := Student{
	        Name: "Sam", Subjects: [2]string{"Math", "Music"},
	    }
	
	    clark = sam //clark.Subject和sam.Subject不同的Array
	    clark.Name = "Clark"
	    clark.Subjects[1] = "Philosophy" //sam.Subject不受影响！
	    fmt.Printf("Sam : %v\n", sam)
	    fmt.Printf("Clark : %v\n", clark)
	}
	
	执行结果：
	Sam : {Sam [Math Music]}
	Clark : {Clark [Math Philosophy]}
```



编写代码时，建议这样规避上述问题：
*	结构体内尽可能不定义Slice、Maps成员；
*	如果结构体有Slice、Maps成员，尽可能以小写开头、控制其访问；
*	结构体的赋值和复制，尽可能通过自定义的深度拷贝函数进行；

5.【推荐】make申请slice/map时，根据预估大小来申请合适内存。

说明：map和数组不同，可以根据新增的<key,value>对动态的伸缩，因此它不存在固定长度或者最大限制。


map的空间扩展是一个相对复杂的过程，每次扩容会增加到上次大小的两倍。它的结构体中有一个buckets和oldbuckets，用来实现增量扩容，正常情况下直接使用buckets，oldbuckets为空，如果当前哈希表正在扩容，则oldbuckets不为空，且buckets大小是oldbuckets大小的两倍。对于大的map或者会快速扩张的map，即便只是大概知道容量，也最好先标明。


slice是一个C语言动态数组的实现，在对slice进行append等操作时，可能会造成slice的自动扩容，其扩容规则：
	如果新的大小是当前大小2倍以上，则大小增长为新大小
	否则循环以下操作：如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长，直到增长的大小超过或者等于新大小


推荐做法：在初始化map时指明map的容量。
1.	map := make(map[string]float, 100)


## （六） 并发处理	


1.【强制】在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数


```
fori:=0;i<limit;i++{
    go func(){ DoSomething(i) }() //错误的做法
    go func(i int){ DoSomething(i) }(i)//正确的做法
￼}
```

2.【强制】确保每个goroutine都能退出。

说明：Goroutine是Go并行设计的核心，在实现功能时不可避免会使用到，执行goroutine时会占用一定的栈内存。


启动goroutine就相当于启动了一个线程，如果不设置线程退出的条件就相当于这个线程失去了控制，占用的资源将无法回收，导致内存泄露。


错误示例：示例中ready()启动了一个goroutine循环打印信息到屏幕上，这个goroutine无法终止退出。

```
	package main
	
	import (
	    "fmt"
	    "time"
	)
	
	func ready(w string, sec int) {    
	    go func() { // ## 【错误】goroutine启动之后无法终止
	        for {
	            time.Sleep(time.Duration(sec) * time.Second)
	            fmt.Println(w, "is ready! ")
	        }
	    }()
	}
	
	func main() {
	    ready("Tea", 2) 
	    ready("Coffee", 1)
	    fmt.Println("I'm waiting")
	    time.Sleep(5 * time.Second)
	}
```



推荐做法：对于每个goroutine都需要有退出机制，能够通过控制goroutine的退出，从而回收资源。通常退出的方式有：
*	使用标志位的方式；
*	信号量；
*	通过channel通道通知；


注意：channel是一个消息队列，一个goroutine获取signal后，另一个goroutine将无法获取signal，以下场景下每个channel对应一个goroutine

```
	package main
	
	import (
	    "fmt"
	    "time"
	)
	
	func ready(w string, sec int, signal chan struct{}) {
	    go func() {
	        for {
	            select {
	            case <-time.Tick(time.Duration(sec) * time.Second):
	                fmt.Println(w, "is ready! ")
	            case <-signal: // 对每个goroutie增加一个退出选项 
	                fmt.Println(w, "is close goroutine!")
	                return
	            }
	        }
	    }()
	}
	
	func main() {
	    signal1 := make(chan struct{}) // 增加一个signal
	    ready("Tea", 2, signal1)
	
	    signal2 := make(chan struct{}) // 增加一个signal
	    ready("Coffee", 1, signal2)
	
	    fmt.Println("I'm waiting")
	    time.Sleep(4 * time.Second)
	    signal1 <- struct{}{}
	    signal2 <- struct{}{}
	    time.Sleep(4 * time.Second)
	}
```


3.【强制】禁止在闭包中直接引用闭包外部的循环变量。

说明：Go语言的特性决定了它会出现其它语言不存在的一些问题，比如在循环中启动协程，当协程中使用到了循环的索引值，往往会出现意想不到的问题，通常需要程序员显式地进行变量调用。

```
	for i := 0; i < limit; i++ {
	    go func() { DoSomething(i) }()        //错误做法
	    go func(i int) { DoSomething(i)}(i)   //正确做法
	}
```


4.【强制】传递channel类型的参数时应该区分其职责。

在只发送的功能中,传递channel类型限定为: c chan<- int
在只接收的功能中,传递channel类型限定为: c <-chan int


5.【强制】确保对channel是否关闭做检查。

说明：在调用方法时不能想当然地认为它们都会执行成功，当错误发生时往往会出现意想不到的行为，因此必须严格校验并合适处理函数的返回值。例如：channel在关闭后仍然支持读操作，如果channel中的数据已经被读取，再次读取时会立即返回0值与一个channel关闭指示。如果不对channel关闭指示进行判断，可能会误认为收到一个合法的值。因此在使用channel时，需要判断channel是否已经关闭。


错误示例：下面代码中若cc已被关闭，如果不对cc是否关闭做检查，则会产生死循环。


```
	package main
	import (
	    "errors"
	    "fmt"
	    "time"
	)
	
	func main() {
	    var cc = make(chan int)
	    go client(cc)
	
	    for {
	        select {
	            case <-cc: //## 【错误】当channel cc被关闭后如果不做检查则造成死循环
	            fmt.Println("continue")
	            case <-time.After(5 * time.Second):
	            fmt.Println("timeout")
	        }
	    }
	}
	
	func client(c chan int) {
	    defer close(c)
	
	    for {
	        err := processBusiness()
	        if err != nil {
	            c <- 0
	            return
	        }
	        c <- 1
	    }
	}
	
	func processBusiness() error {
	    return errors.New("domo")
	}

```


推荐做法：对通道增加关闭判断。

```
	// 前面代码略……
	for {
	    select {
	    case _, ok := <-cc:
	        // 增加对chnnel关闭的判断，防止死循环
	        if ok == false {
	            fmt.Println("channel closed")
	            return
	        }
	        fmt.Println("continue")
	    case <-time.After(5 * time.Second):
	        fmt.Println("timeout")
	    }
	}
	// 后面代码略……
```



6.【强制】禁止重复释放channel。

说明：重复释放channel会触发run-time panic，导致程序异常退出。重复释放一般存在于异常流程判断中，如果恶意攻击者能够构造成异常条件，则会利用程序的重复释放漏洞实施DoS攻击。


错误示例：

```
	func client(c chan int) {
	    defer close(c)
	    for {
	        err := processBusiness()

	        if err != nil {
	            c <- 0
	            close(c) // ## 【错误】可能会产生双重释放
	            return
	        }
	        c <- 1
	    }
	}
```



推荐做法：确保创建的channel只释放一次。

```
	func client(c chan int) {
	    defer close(c)
	
	    for {
	        err := processBusiness()
	        if err != nil {
	            c <- 0     // ## 【修改】使用defer延迟close后，不再单独进行close
	            return
	        }
	        c <- 1
	    }
	}
```

7.【推荐】为高并发的轻量级任务处理创建routine池。

说明：Routine是轻量级的，但对于高并发的轻量级任务处理，频繁创建routine来执行，执行效率也是非常低效率的。


推荐做法：高并发的轻量级任务处理，需要使用routine池，避免对调度和GC带来冲击。


8.【推荐】长调用链或在函数中避免申明较多较大临时变量。

routine的调用栈默认大小1.7版本已修改为2K，当栈大小不够时，Go运行时环境会做扩栈处理，创建10000个routine占用空间才20M，所以routine非常轻量级，可以创建大量的并发执行逻辑。而线程栈默认大小是1M，当然也可以设置到8K（有些系统可以设置4K），一般不会这么做，因为线程栈大小是固定的，不能随需而变大，不过实际CPU核一般都在100以内，线程数是足够的。


routine是怎么实现可变长栈呢？当栈大小不够时，它会新创建一个栈，通常是2倍大小增长，然后把栈赋值过来，而栈中的指针变量需要搜索出来重新指向新的栈地址，好处不是随便有的，这里就明显有性能开销，而且这个开销不小。


说明：频繁创建的routine，要注意栈生长带来的性能风险，比如栈最终是2M大小，极端情况下就会有数10次扩栈操作，从而让性能急剧下降。所以必须控制调用栈和函数的复杂度，routine就意味着轻量级。


对于比较稳定的routine，也要注意它的栈生长后会导致内存飙升。

9.【推荐】高并发时避免共享对象互斥。

说明：在Go中，可以轻易创建10000个routine而对系统资源通常就是100M的内存要求，但是并发数多了，在多线程中，当并发冲突在4个到8个线程间时，性能可能就开始出现拐点，急剧下降，这同样适应于Go，Go可以轻易创建routine，但对并发冲突的风险必须要做实现的处理。


推荐做法：routine需要是独立的，无冲突的执行，若routine间有并发冲突，则必须控制可能发生冲突的并发routine个数，避免出现性能恶化拐点。

10.【推荐】避免高并发调用同步系统接口。

说明：编程世界同步场景更普遍，GO提供了轻量级的routine，用同步来模拟异步操作，故在高并发下的，相比线程，同步模拟代价比较小，可以轻易创建数万个并发调用。然而有些API是系统函数，而这些系统函数未提供异步实现，程序中最常见的posix规范的文件读写都是同步，epoll异步可解决网络IO，而对regular file是无法工作的。Go的运行时环境不可能提供超越操作系统API的能力，它依赖于系统syscall文件中暴露的api能力，而1.6版本还是多线程模拟，线程创建切换的代价也非常巨大，开源库中有filepoller来模拟异步其实也基于这两种思路，效率上也会大打折扣。


推荐做法：把诸如写文件这样的同步系统调用，要隔离到可控的routine中，而不是直接高并发调用。

## （七） 控制语句	

1.【强制】尽早return：一旦有错误发生，马上返回。

举例：不要使用

```
if err != nil {
    // error handling
} else {
    // normal code
}
```

而推荐使用：

```
if err != nil {
     // error handling
     return // or continue, etc.
}
```

说明：这样可以减少嵌套深度，代码更加美观。


2.【推荐】if条件判断, 同时使用超过3个表达式以上的时候, 使用switch替代。

例如:

```
	if a == 0 || a == 1 || a == 2 || a == 3 {
	    // ...
	}
```



建议改写为:

```
	switch a {
	case 0, 1, 2, 3:
	    // ....
	}
```

3.【推荐】定义bool变量时，要避免判断时出现双重否定，应使用肯定形式的表达式。

举例：

```
	if !notFailed && !isReported { // 晦涩，不容易理解
	    notifyUser()
	} else {
	    process()
	}
```



应改为：

```
	if isSuccess || isReported {
	    process()
	} else {
	    notifyUser()
	}
```



4.【推荐】for循环初始值从0开始，判断条件使用<无等号的方式。

举例：

```
	for i := 1; i <= 10; i++ {
	    doSomeThing()
	}
```


应改为：

```
	for i := 0; i < 10; i++ {
	    doSomeThing()
	}
```

这样子可以迅速准确得出循环次数。

5.【推荐】 将 for-select 封装到函数中

如果在某个条件下，你需要从 for-select 中退出，就需要使用标签。例如：


```

func main() {

L:
    for{

        select {

        case<-time.After(time.Second):

            fmt.Println("hello")

        default:
        
            break L
        }

    }

    fmt.Println("ending")

}
```
如你所见，需要联合break使用标签。这有其用途，不过我不喜欢。这个例子中的 for 循环看起来很小，但是通常它们会更大，而判断break的条件也更为冗长。

如果需要退出循环，我会将 for-select 封装到函数中：

```
func main() {

    foo()
    
    fmt.Println("ending")
}

func foo() {

    for{

        select {

        case<-time.After(time.Second):

            fmt.Println("hello")

        default:

            return
        }
    }
}
```
你还可以返回一个错误（或任何其他值），也是同样漂亮的，只需要：


```

// 阻塞


if err := foo(); err != nil {

    // 处理 err

}
```

6.【推荐】如果函数存在多个返回的地方，则采用defer来完成如关闭资源、解锁等清理操作。

说明：Go的defer语句用来调度一个函数调用（被延期的函数），在函数即将返回之前defer才被运行。这是一种不寻常但又很有效的方法，用于处理类似于不管函数通过哪个执行路径返回，资源都必须要被释放的情况。典型的例子是对一个互斥解锁，或者关闭一个文件。


7.【推荐】defer会消耗更多的系统资源，不建议用于频繁调用的方法中。

8.【推荐】避免在for循环中使用defer。

说明：一个完整defer过程要处理缓存对象、参数拷贝，以及多次函数调用，要比直接函数调用慢得多。


错误示例：实现一个加解锁函数，解锁过程使用defer处理。这是一个非常小的函数，并且能够预知解锁的位置，使用defer编译后会使处理产生很多无用的过程导致性能下降。

```
	var lock sync.Mutex
	func testdefer() {
	    lock.Lock()
	    defer lock.Unlock()
	}
	
	func BenchmarkTestDefer(b *testing.B) {
	    for i := 0; i < b.N; i++ {
	        testdefer()
	    }
	}
	
	// 耗时结果
	BenchmarkTestDefer 10000000 211 ns/op
```



推荐做法：如果能够明确函数退出的位置，可以选择不使用defer处理。保证功能不变的情况下，性能明显提升，是耗时是使用defer的1/3。

```
	var lock sync.Mutex
	func testdefer() {
	    lock.Lock()
	    lock.Unlock() // ## 【修改】去除defer
	}
	
	func BenchmarkTestDefer(b *testing.B) {
	    for i := 0; i < b.N; i++ {
	        testdefer()
	    }
	}
	
	// 耗时结果
	BenchmarkTest" 30000000 43.5 ns/op
```


## （八） 注释规约	

Go提供了C风格的块注释/* */和C++风格的行注释//。通常为行注释；块注释大多数作为程序包的注释，但也可以用于一个表达式中，或者用来注释掉一大片代码。

godoc用来处理Go源文件，抽取有关程序包内容的文档。在顶层声明之前出现，并且中间没有换行的注释，会随着声明一起被抽取，作为该项的解释性文本。这些注释的本质和风格决定了godoc所产生文档的质量。

Go代码的注释可以被godocs工具转化为文档发布。所以准确的代码注释除了能够帮助阅读代码还有助于代码手册的生成。

Godoc工具说明可参考如下链接：
https://godoc.org/golang.org/x/tools/cmd/godoc

1.【强制】编写代码首先考虑如何代码自我解释，然后才是添加注释进行补充说明
说明：优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，需要很多注释来解释的代码往往存在坏味道，需要重构。


示例：注释不能消除代码的坏味道：

```
	// 判断m是否为素数
	// 返回值：: 1是素数，0不是素数
	func p(m int) int {
	    var i, k int
	
	    k = sqrt(m)
	    for i = 2; i <= k; i++ {
	        if m%i == 0 {
	            break // 发现整除，表示m不为素数，结束遍历
	        }
	    }
	
	    // 遍历中没有发现整除的情况，返回
	    if i > k {
	        return 1
	    }
	
	    // 遍历中没有发现整除的情况，返回
	    return 0
	}
```


重构代码后，不需要注释：

```
	// IsPrimeNumber return true if num is prime
	func IsPrimeNumber(num int) bool {
	    var i int
	    sqrtOfNum := sqrt(num)
	

	    for i = 2; i <= sqrtOfNum; i++ {

	        if num%i == 0 {
	            return false
	        }
	    }
	
	    return true
	}
```

2.【强制】注释的内容要清楚、明了，含义准确，防止注释二义性。

说明：有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间。
示例：注释与代码相矛盾，注释内容也不清楚，前后矛盾。

```
	// 上报网管时要求故障ID与恢复ID相一致
	// 因此在此由告警级别获知是不是恢复ID 
	// 若是恢复ID则设置为ClearId，否则设置为AlarmId 
	if ClearAlarmLevel != rcData.level {
	    SetAlarmID(rcData.AlarmId);
	} else {
	    SetAlarmID(rcData.ClearId);
	}
```

正确做法：修改注释描述如下：
```
	// 网管达成协议：上报故障ID与恢复ID由告警级别确定，若是清除级别，ID设置为ClearId，否则设为AlarmId
	
	...
```

3.【强制】在代码的功能、意图层次上进行注释，即注释用于解释代码难以直接表达的意图，而不是重复描述代码。

说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。

对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。
注释不是为了名词解释（what），而是说明用途（why）。


示例：如下注释纯属多余。

```
	i++ // increment i
	if receiveFlag { // if receiveFlag is TRUE
	
	...
```


如下这种无价值的注释不应出现（空洞的笑话，无关紧要的注释）。

```
	// 时间有限，现在是:04，根本来不及想为什么，也没人能帮我说清楚
	...
```

而如下的注释则给出了有用的信息：

```
	//由于xx编号网上问题，在xx情况下，芯片可能存在写错误，此芯片进行写操作后，必须进行回读校验，如果回读不正确，需要再重复写-回读操作，最多重复三次，这样可以解决绝大多数网上应用时的写错误问题
	time := 0
	
	for (readReg(someAddr) != value) && (time < 3) {
	   writeReg(someAddr, value)
	   time++
	}
```


对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释，出彩的或复杂的代码块前要加注释，如：

```
	// Divide result by two, taking into account that x contains the carry from the add.
	for i := 0; i < len(result); i++ {
	    x = (x << 8) + result[i]
	    result[i] = x >> 1
	    x &= 1
	}
```



4.【强制】所有导出对象都需要注释说明其用途；非导出对象根据情况进行注释。必须时，应该说明值的取值范围，及默认值。

5.【强制】注释的单行长度不能超过 80 个字符。

6.【强制】注释需要紧贴对应的包声明和函数之前，不能有空行、

7.【强制】非跨度很长的注释，尽量使用 // 方式。

```
	/*
	*    1. 确保 template 存在
	*/
```


改成：
```
	// 1. 确保 template 存在
```

8.【推荐】避免多余的空格，两句注释之间保持一个空格。

示例：

```

// 采用这样的方式
// Sentence one. Sentence two.
	
// 而不是如下的方式
// Sentence one.  Sentence two.
	
```

保持和Go的风格一样，参考https://golang.org/cl/20022


9.【强制】注释第一条语句应该为一条概括语句，并且使用被声明的名字作为开头。

例如：

```
// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
```



10.【推荐】//与注释的文档之间空一格。

示例：

```
// 采用如下方式
// This is a comment
// for humans.

//而不要采用如下方式:
//This is a comment
//for humans.
```


对于Go保留的语法，就不需要空一格
```
	//go:generate go run gen.go
```

详细的语法可以参考：https://golang.org/cmd/compile/#hdr-Compiler_Directives.


11.【强制】每个程序包都应该有一个包注释，一个位于package子句之前的块注释。

对于有多个文件的程序包，包注释只需要出现在一个文件中，任何一个文件都可以。包注释应该用来介绍该程序包，并且提供与整个程序包相关的信息。它将会首先出现在godoc页面上，并会建立后续的详细文档。

```
1.	/*
	Package regexp implements a simple library for regular expressions.
	
	The syntax of the regular expressions accepted is:
	
	    regexp:
	        concatenation { '|' concatenation }
	    concatenation:
	        { closure }
	    closure:
	        term [ '*' | '+' | '?' ]
	    term:
	        '^'
	        '$'
	        '.'
	        character
	        '[' [ '^' ] character-ranges ']'
	        '(' regexp ')'
	*/
	package regexp
```

如果程序包很简单，则包注释可以非常简短。

```
// Package path implements utility routines for
// manipulating slash-separated filename paths.
```

12.【强制】不要依靠用空格进行对齐。

注释不需要额外的格式，例如星号横幅。生成的输出甚至可能会不按照固定宽度的字体进行展现，所以不要依靠用空格进行对齐—godoc，就像gofmt，会处理这些事情。注释是不作解析的普通文本，所以HTML和其它注解，例如_this_，将会逐字的被复制。对于缩进的文本，godoc确实会进行调整，来按照固定宽度的字体进行显示，这适合于程序片段。fmt package的包注释使用了这种方式来获得良好的效果。


根据上下文，godoc甚至可能不会重新格式化注释，所以要确保它们看起来非常直接：使用正确的拼写，标点，以及语句结构，将较长的行进行折叠，等等。

13.【推荐】定义结构体时，类型定义一般都以单数信息描述。

示例：

```
	// Request represents a request to run a command.
	type Request struct { ...
```



如果为接口，则一般以以下形式描述。

示例：

```
	// FileInfo is the interface that describes a file and is returned by Stat and Lstat.
	type FileInfo interface { ...
```


14.【推荐】函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等

说明：重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。


15.【推荐】如果函数或者方法为判断类型（返回值主要为bool类型），则以 <name> returns true if 开头。

如下例所示：

```
	// HasPrefix returns true if name has any string in given slice as // prefix.
	func HasPrefix(name string, prefixes []string) bool { ...
```

16.【推荐】对于变量和常量的注释可以对声明进行组合。  
说明：单个的文档注释可以用来介绍一组相关的常量或者变量。由于展现的是整个声明，这样的注释通常非常简单的。

```
	// Error codes returned by failures to parse an expression.
	var (
	    ErrInternal      = errors.New("regexp: internal error")
	    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
	    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
	    ...
	)
```



一般建议采用这样的方式：

```
	var (
	    // BConfig is the default config for Application
	    BConfig *Config
	
	    // AppConfig is the instance of Config, store the config information from file
	    AppConfig *beegoAppConfig
	
	    // AppPath is the absolute path to the app
	    AppPath string
	
	    // GlobalSessions is the instance for the session manager
	    GlobalSessions *session.Manager
	)
```

17.【推荐】在编码阶段应该同步写好 变量、函数、包 的注释，最后可以利用 godoc 命令导出文档。  
说明：注释必须是完整的句子，句子的结尾应该用句号作为结尾（英文句号）。注释推荐用英文，可以在写代码过程中锻炼英文的阅读和书写能力。而且用英文不会出现各种编码的问题。

18.【推荐】针对代码中出现的bug，可以采用如下教程使用特殊的注释，在godocs中可以做到注释高亮  
　　
示例：

```
// BUG(astaxie):This divides by zero. 
var i float = 1/0
```

19.【强制】带mutex的struct必须是指针receivers  
说明：如果你定义的struct中带有mutex,那么你的receivers必须是指针

20.【强制】当某个部分等待完成时，可用 TODO: 开头的注释来提醒维护人员。  

21.【强制】当某个部分存在已知问题进行需要修复或改进时，可用 FIXME: 开头的注释来提醒维护人员。  

22.【强制】当需要特别说明某个问题时，可用 NOTE: 开头的注释：  

23.【强制】针对代码中出现的bug，可以采用BUG(who):注释，这些注释将被识别为已知的bug，并包含在文档的BUGS区。而其中的who应该是那些可以提供关于这个BUG更多信息的用户名。


比如，下面就是一个bytes包中已知的问题：

```
1.	// BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
```

24.【强制】避免在for循环中使用time.Tick()函数。

如果在for循环中使用time.Tick()，它会每次创建一个新的对象返回，应该在for循环之外初始化一个ticker后，再在循环中使用：

```
	ticker := time.Tick(time.Second)
	for {
	    select {
	        case <-ticker:
	        // …
	    }
	}
```

## （九） 其它	
1.【推荐】在代码中编写字符串形式的json时，使用反单引号，而不是双引号。
例如：
"{\"key\":\"value\"}"


改为格式更清晰的：

```
`
{
    "key":"value"
}
`
```
2.【推荐】 对于少量数据，不要传递指针  
3.【推荐】 对于大量数据的 struct 可以考虑使用指针

4.【推荐】 注意自定义类型的string循环问题

如果自定义的类型定义了String方法，那么在打印的时候会产生隐藏的一些bug

```
type MyInt int
func (m MyInt) String() string { 
    return fmt.Sprint(m)   //BUG:死循环
}

func(m MyInt) String() string { 
    return fmt.Sprint(int(m))   //这是安全的,因为我们内部进行了类型转换
}
```


5.【推荐】基本类型传递时，尽量使用值传递。

6.【推荐】如果传递字符串或者接口对象时，建议直接实例传递而不是指针传递。

7.【推荐】如果是map、func、chan，那么直接用T。

8.【推荐】】如果是slice，method里面不重新reslice之类的就用T。

9.【推荐】如果想通过method改变里面的属性，那么请使用*T。

10.【推荐】】如果是struct，并且里面包含了sync.Mutex之类的同步原语，那么请使用*T，避免copy。

11.【推荐】如果是一个大型的struct或者array，那么使用*T会比较轻量，效率更高。

12.【推荐】如果是struct、slice、array里面的元素是一个指针类型，然后调用函数又会改变这个数据，那么对于读者来说采用*T比较容易懂。

13.【推荐】其它情况下，建议采用*T。

14.【强制】一个文件只定义一个init函数。

15.【强制】一个包内的如果存在多个init函数，不能有任何的依赖关系。

注意如果包内有多个init，每个init的执行顺序是不确定的。

# 二、 异常日志
## （一） 异常处理	

1.【强制】错误处理的原则就是不能丢弃任何有返回err的调用，不要采用_丢弃，必须全部处理。接收到错误，要么返回err，要么实在不行就panic，或者使用log记录下来

2.【强制】error的信息不要采用大写字母，尽量保持你的错误简短，但是要足够表达你的错误的意思。

3.【强制】导出的错误变量的命名，以Err开始，如ErrSomething，无需导出的错误变量命名，以Error作为后缀，如specificError


举例：

```
	// 包级别的导出error.
	var ErrSomething = errors.New("something went wrong")
	
	func main() {
	    // 通常情况下我们只需要使用"err"
	    result, err := doSomething()
	    // 但是你也可以申明一个新的长名字变量，例如 "somethingError". 

	    // Error作为后缀

	    var specificError error
	    result, specificError = doSpecificThing()
	    // ... 后面就使用specificError.
	}
```


不好的例子:

```
	var ErrorSomething = errors.New("something went wrong")
	var SomethingErr = errors.New("something went wrong")
	func main() {
	    var specificErr error
	    result, specificErr = doSpecificThing()
	    var errSpecific error
	    result, errSpecific = doSpecificThing()
	    var errorSpecific error
	    result, errorSpecific = doSpecificThing()
	}
```


4.【强制】公共包内禁止使用panic，如果有panic需要内部recover并返回error。

说明：只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法正常运行，但是对于其他的package对外的接口不能有panic。

强烈建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。

## （二） 日志规约	

# 三、 单元测试	
# 四、 安全规约	

1.【强制】避免在循环引用调用 runtime.SetFinalizer。

说明：指针构成的 "循环引用" 加上 runtime.SetFinalizer 会导致内存泄露。


runtime.SetFinalizer用于在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中。在对象被 GC 进程选中并从内存中移除以前，SetFinalizer 都不会执行，即使程序正常结束或者发生错误。


错误示例：垃圾回收器能正确处理 "指针循环引用"，但无法确定 Finalizer 依赖次序，也就无法调用Finalizer 函数，这会导致目标对象无法变成不可达状态，其所占用内存无法被回收。

```
	package main
	
	import (
	    "fmt"
	    "runtime"
	    "time"
	)
	
	type Data struct {
	    d [1024 * 100]byte
	    o *Data
	}
	
	func test() {
	    var a, b Data
	    a.o = &b
	    b.o = &a
	
	    // ## 【错误】循环和SetFinalize同时使用
	    runtime.SetFinalizer(&a, func(d *Data) { fmt.Printf("a %p final.\n", d) })
	    runtime.SetFinalizer(&b, func(d *Data) { fmt.Printf("b %p final.\n", d) })
	}
	
	func main() {    
	    for { // ## 【错误】循环和SetFinalize同时使用
	        test()
	        time.Sleep(time.Millisecond)
	    }
	}
```



通过跟踪GC的处理过程，可以看到如上代码内存在不断的泄露：
go build -gcflags "-N -l" && GODEBUG="gctrace=1" ./test
gc11(1): 2+0+0 ms, 104 -> 104 MB 1127 -> 1127 (1180-53) objects
gc12(1): 4+0+0 ms, 208 -> 208 MB 2151 -> 2151 (2226-75) objects
gc13(1): 8+0+1 ms, 416 -> 416 MB 4198 -> 4198 (4307-109) objects
以上结果标红的部分代表对象数量，我们在代码中申请的对象都是局部变量，在正常处理过程中GC会持续的回收局部变量占用的内存。但是在当前的处理过程中，内存无法被GC回收，目标对象无法变成不可达状态。


推荐做法：需要避免内存指针的循环引用以及runtime.SetFinalizer同时使用。

# 五、 工程结构	
## （一） 应用分层

1.【强制】合理规划目录，一个目录中只包含一个包（实现一个模块的功能），如果模块功能复杂考虑拆分子模块，或者拆分目录。

说明：在Go中对于模块的划分是基于package这个概念，可以在一个目录中可以实现多个package，但是并不建议这样的实现方式。主要的缺点是模块之间的关系不清晰，另外不利于模块功能扩展。


错误示例：

```
project
│  config.go
│  controller.go
│  filter.go
│  flash.go
│  log.go
│  memzipfile.go
│  mime.go
│  namespace.go
│  parser.go
│  router.go
│  staticfile.go
│  template.go
│  templatefunc.go
│  tree.go
│  util.go
|  validation.go
|  validators.go
```



推荐做法： 

```
project  
├─cache  
│  │  cache.go  
│  │  conv.go  
│  │        
│  └─redis  
│          redis.go  
├─config  
│  │  config.go  
│  │  fake.go  
│  │  ini.go  
│  └─yaml  
│          yaml.go  
├─logs  
│      conn.go  
│      console.go  
│      file.go  
│      log.go  
│      smtp.go  
└─validation  
        util.go  
        validation.go  
        validators.go
```


## （二） 二方库依赖	

1.【强制】项目仓库中包含全量的代码

说明：将依赖源码都放到当前工程的vendor目录下，将全量的代码保存到项目仓库中，这样做有利于避免受第三方变动的影响。

2.【推荐】建议采用 Glide 来管理第三方包

第三方包应该尽量获取release版本，而非master分支的版本。master上的版本通常是正在开发的非稳定版本


# 六、 设计规约	
1.【推荐】使用单一的 GOPATH  

虽说Go语言支持拥有多个 GOPATH，但多个GOPATH的情况并不具有弹性。GOPATH本身就是高度自我完备的（通过导入路径）。有多个 GOPATH 会导致某些副作用，例如可能使用了给定的库的不同的版本。你可能在某个地方升级了它，但是其他地方却没有升级。只使用单一的 GOPATH，这会提升 Go 的开发进度。

除非你的项目很大并且极为重要，否则不要为每个项目使用不同的 GOPAHT。如果你认为项目需要一个自己的 GOPATH 目录，那么就创建它，否则不要尝试使用多个 GOPATH。它只会拖慢你的进度。

	所有项目共用一个workspace，如下图所示：

```
workspace/  
├── bin  
├── pkg  
│   └── linux_amd64  
│         
└── src  
    ├── project1  
    │     
└── project2  
    │     
    └── project3  
    │     
    └── …
```


优点： 方便发布到github.com, 让第三方通过go get等工具获取。


内部项目，建议采用第一种工程结构。公开项目、提供给第三方集成的项目采用第二种项目结构。

2.【推荐】合理的设计引用包的格式  

说明：import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：

```
import (
    "fmt"
)
```

如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：

```
import (
    "encoding/json"
    "strings"

    "myproject/models"
    "myproject/controller"
    "myproject/utils"

    "github.com/astaxie/beego"
    "github.com/go-sql-driver/mysql"
)
```

有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。


3.【强制】禁止使用相对路径导入（./subpackage），所有导入路径必须符合 go get 标准。

错误示例： 

```
	// 这是不好的导入
	import "../net"
```

正确做法：

```
	// 这是正确的做法
	import "github.com/repo/proj/src/net"
```

4.【参考】代码质量保证优先原则：  
（1）正确性，指程序要实现设计要求的功能。    
（2）简洁性，指程序易于理解并且易于实现。  
（3）可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。  
（4）可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。  
（5）代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。  
（6）代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。  
（7）可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。  


5.【强制】对于主要功能模块抽象模块接口，通过interface提供对外功能。


说明：Go语言其中一个特殊的功能就是interface，它让面向对象，内容组织实现非常的方便。正确的使用这个特性可以使模块的可测试性和可维护性得到很大的提升。对于主要功能包（模块），在package包主文件中通过interface对外提供功能。


示例：在buffer包的buffer.go中定义如下内容

```
	package buffer
	
	import (
	    "policy_engine/models"
	)
	
	//other code …
	type MetricsBuffer interface {
	    Store(metric *DataPoint) error
	    Get(dataRange models.MatchPolicyDataRange) (*MetricDataBuf, error)
	    Clear(redisKey string) error
	    Stop()
	    Stats() []MetrisBufferStat
	    GetByKey(metricKey string) []DataPoint
	}
```



使用buffer package的代码示例，通过interface定义，可以在不影响调用者使用的情况下替换package。基于这个特性，在测试过程中，也可以通过实现符合interface要求的类来打桩实现测试目的。

```
	package metrics
	
	import (
	...//other import
	    "policy_engine/worker/metrics/buffer"
	)
	
	type MetricsClient struct {
	    logger            lager.Logger
	    redisClient       *store.RedisClient
	    conf              *config.Config
	    metricsBuffer     buffer.MetricsBuffer //interface类型定义的成员
	    metricsStatClient *metricstat.MetricsStatClient
	    stopSignal        chan struct{}
	}
	
	func New(workerId string, redisClient *store.RedisClient, logger lager.Logger, conf *config.Config) *MetricsClient {
	    var metricsBuffer MetricsBuffer
	    if conf.MetricsBufferConfig.StoreType == config.METRICS_MEM_STORE {
	        //具有interface定义函数的package实现，通过内存保存数据
	        metricsBuffer = NewMemBuffer(logger, conf)  
	    } else if conf.MetricsBufferConfig.StoreType == config.METRICS_REDIS_STORE {
	        //具有interface定义函数的package实现，通过redis保存数据
	        metricsBuffer = NewRedisBuffer(redisClient, logger, conf) 
	    } else {
	      ... //other code
	    }
	    ... //other code
	}
```

# 七、区块链安全

## 一、 编写目的

&emsp;&emsp;区块链技术目前的发展方兴未艾，我们目前的应用还处于前期的阶段，其安全问题也日益受到行业关注，随着区块链应用范围逐渐扩大，安全是必须重视的课题。为减少应用上线后带来潜在的安全风险，特拟定安全代码编写规范。  

## 二、 使用范围

&emsp;&emsp;本规范适用普华商业集团区块链项目。  

## 三、 应用安全设计

&emsp;&emsp;在总体架构设计阶段，需明确与需求方沟通确认对于软件安全的相关要求，对于有明确安全要求的（例如授权管理要求、用户认证要求、日志审计要求等），须在设计文档中予以详细说明。对于互联网应用，务必明确网络安全、应用安全、数据安全相关的安全防护手段。  

&emsp;&emsp;在部署架构上，应采用各节点服务器、数据库服务器的分离部署模式，在节点服务器被攻击或者因某种原因导致服务器不能使用时，不会导致核心应用数据的丢失。如软件产品具备有条件时，应优先采用加密数据传输方式（因为区块链服务器目前底层，故目前连接都使用内网连接，采用http协议。）。  

&emsp;&emsp;对于核心接口或者重要数据应采用加密的形式，避免直接暴露接口参数及数据。在外部接口设计方面，应采用最小接口暴露的原则，避免开发不必要的服务方法带来相关安全隐患，同时对于第三方接口，应共同商定第三方接入的身份认证方式和手段。
 
## 四、 区块链（以太坊）目前已知安全问题总结

### 4.1.整型溢出  

&emsp;&emsp;“整数溢出漏洞”属于极度危险等级漏洞；漏洞引起的事件类型包括：超额铸币、超额购币、随意铸币、高卖低收、下溢增持等等；例如可导致原交易发起人使用0个或者少量的币就可以给其他地址转入大量的代币，也就是我们常常听到的代币无限增发。  

解决方案：其实只要在红色方框代码的判断条件再加上  && _value < unit256(cnt) * _value 就可以防止利用整数上溢通过验证进行转账。  
     
### 4.2. 可重入攻击  

&emsp;&emsp;当以太坊智能合约将Ether发送给未知地址（地址来源于输入或是调用者）时，可能会发生此攻击。攻击者可以在地址对应合约的Fallback函数中，构建一段恶意代码。当易受攻击的合约将Ether发送给攻击者构建的恶意合约地址时，将执行Fallback函数，执行恶意代码。恶意代码可以是重新进入易受攻击的合约的相关代码，这样攻击者可以重新进入易受攻击合约，执行一些开发人员不希望执行的合约逻辑。   

解决方案：

1. 在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址/合约调用另一份合约（即重入发送合约）。

1. 确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol - Line[18-19] 应放在 Line[17] 之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 检查效果交互（checks-effects-interactions） 模式。

1. 引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用。

### 4.3.交易顺序依赖

&emsp;&emsp;一笔交易被传播出去并被矿工认同包含在一个区块内需要一定的时间，如果一个攻击者在监听到网络中对应合约的交易，然后发出他自己的交易来改变当前的合约状态，例如对于悬赏合约，减少合约回报，则有一定几率使这两笔交易包含在同一个区块下面，并且排在另一个交易之前，完成攻击。这意味着，如果某个用户正在揭示拼图或其他有价值的秘密的解决方案，恶意用户可以窃取解决方案并以较高的费用复制其交易，以抢占原始解决方案。
解决方案：

&emsp;&emsp;对于交易顺序依赖这个问题，如果智能合约的开发者不小心，这种情况会导致实际的和毁灭性的前端攻击。因此开发者要综合运用gas限制以及披露方案，从而保障交易信息在合理的环节以合理的形式呈现。
 
### 4.4.时间戳依赖

&emsp;&emsp;也被称为时间操纵，如果一位矿工持有合约的股份，他可以通过为他正在挖掘的矿区选择合适的时间戳来获得优势。  
解决方案：    
&emsp;&emsp;时间戳（Timestamps）是由矿工生成。因此，合约不应该让关键操作依赖于区块时间戳，例如把时间戳用作一个生成随机数的种子。Consensys 在他们的指导手册中给出了“12分钟规定”，表明如果你依赖时间戳的代码能够处理 12 分钟的误差，那么使用block.timestamp 是安全的。
 
### 4.5.假充值
&emsp;&emsp;以太坊代币交易回执中status字段是0x1(true)还是0x0(false)，取决于交易事务执行过程中是否抛出了异常（比如使用了 require/assert/revert/throw 等机制）。当用户调用代币合约的 transfer 函数进行转账时，如果 transfer 函数正常运行未抛出异常，该交易的 status 即是 0x1(true)。

解决方案：  
&emsp;&emsp;除了判断交易事务 success 之外，还应二次判断充值钱包地址的 balance 是否准确的增加。其实这个二次判断可以通过 Event 事件日志来进行，很多中心化交易所、钱包等服务平台会通过 Event 事件日志来获取转账额度，以此判断转账的准确性。但这里就需要特别注意合约作恶情况，因为 Event 是可以任意编写的，不是强制默认不可篡改的选项：  
emit Transfer(from, to, value); // value 等参数可以任意定义  
作为平台方，在对接新上线之前，应该做好严格的安全审计，这种安全审计必须强制合约方执行最佳安全实践。  
在编码上，应该严格执行最佳安全实践，并请第三方职业安全审计机构完成严谨完备的安全审计。

### 4.6. Evnet事件

&emsp;&emsp;事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中。来捋这个关系：区块链是打包一系列交易的区块组成的链条，每一个交易“收据”会包含0到多个日志记录，日志代表着智能合约所触发的事件。
&emsp;&emsp;解决方案：
&emsp;&emsp;使用事件监听，就可以很好的解决这个问题首先，需要定义一个事件：
 
```
event Instructor(
       string name,
       uint age
    );
```

    
&emsp;&emsp;这个事件中，会接受两个参数：name 和 age , 也就是需要跟踪的两个信息。然后，需要在setInfo函数中，触发Instructor事件，如：
   
```
function setInfo(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       emit Instructor(_fName, _age);
   }
```

   
### 4.7. Owner权限

&emsp;&emsp;以太坊solidity0.4.22引入了新的构造函数声明形式constructor()，该函数引入的目的是避免编程人员在编写构造函数时的命名错误 （如6月22日，MorphToken事件中“Owned”被写成“owned”，没有注意大小写，使owned函数成为一个普通函数，导致任何账户都能调用它，更改owner变量，转移合约所有权）。然而，由于用户编写函数时习惯性的使用function进行声明，从而导致构造函数constructor的使用引入新的漏洞。

解决方案：
1. 新的constructor使用方法为，前面无function声明：  

```
contract TokenExample{
      constructor () public {
       //...
  }
}
```
 
2. Remix-ide等编译器会对constructor的错误使用产生警告，开发者千万不要忽略编译器告警，推荐更改源码，消除所有编译器警告。
 
## 五、核心安全

> 区块链本质上是一种健壮和安全的分布式状态机，典型的技术构成包括共识算法、P2P通讯、密码学、内存数据库技术和虚拟机。这也构成了区块链必不可少的 5 项核心能力

### 5.1．密码算法的安全性 
从私钥的整个生命周期来看，可以从以下几个方面进行安全分析  

1. 硬件模块抗拆毁、抗功耗分析、错误注入攻击等侧信道分析能力；

1. 随机数生成算法强度，随机数发生器产生随机数的随机性；

1. 密钥与密钥参与运算过程都在硬件当中；

1. 密钥导入导出过程全在硬件中实现；

1. 密钥恢复与备份; 主要关注加密货币，私钥通过助记符来协助恢复， 助记符的安全是关键。

解决措施：  

1. 改变算法

1. 参考其他对于地址的处理方式

### 5.2.共识机制的安全性

&emsp;&emsp;工作量证明面临51%攻击问题，由于工作量证明需要大量的算力，当一个攻击者拥有大量的算力优势时，找到一个区块的概率会大于其他其他节点，这时攻击者具备了修改自己已发生的交易的能力。

权益证明中，攻击者需要持有51%的Token量才能攻击成功，它相比于拥有51%的算力更难做到。

解决措施：

1. 充分了解每个共识机制的优劣势

1. 选择合适的共识机制或者设计新的共识机制

### 5.3．智能合约安全
&emsp;&emsp;智能合约（Smart contract）：以信息化方式传播、验证或执行合同的计算机协议。在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转，从审计方向上讲大方向上是对合约中危险函数的使用，加密的生成和数据传递等方面进行安全审计

### 5.4. P2P通讯安全
&emsp;&emsp;为了实现解决某系特殊场合的要求，超级账本孕育而生。虽然 Fabric 没有实现去中心化，却可以通过划分不 同节点之间的工作负载实现优化网络效率。为了保证区块链网 络的安全性、可信赖性及可测量性，Fabric 采用 Gossip 作为 P2P 网络传播协议。

常见的P2P网络攻击有：

1. 女巫攻击：攻击者可以十分轻易地去伪造身份加入网络。之后他们会试图去获取网络中大量的节点IP，并根据此做出一些恶意行为

1. Eclipse攻击：此攻击通常要配合Sybil攻击。攻击者通过侵占网络中节点的路由，将足够多的虚假节点添加到某个受害者周围，从而将正常节点隔离在区块链外部。

1. DDos攻击：区块链中，DDos又不同于常见的中心化系统。新型的DDoS攻击不需要建立僵尸网络即可发动大规模攻击，不仅成本低、威力巨大，而且还能确保攻击者的隐秘性。

 

## 六 、总结

&emsp;&emsp;区块链应用从架构上分为三层：基础网络、平台层和应用层，三个层面相互影响，每一个环节出现的问题，都将给下个环节带来更多的安全问题。因此，在进行区块链项目的开发过程中，从设计到实现，从验证到响应，不仅仅需要考虑到单个环节的安全性问题，也需要将其放入到整体的层面中去判断可能出现的风险点。

&emsp;&emsp;从发展形势上看，区块链系统安全受多个层面影响，攻击手段日益升级，损失不断增加。必须加强区块链安全威胁分析和检测手段建设，提高防护水平。

# 附1：专有名词解释	  

1.二方库:公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。