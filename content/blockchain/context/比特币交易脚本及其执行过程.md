**Contents**
  - [比特币交易脚本概述](#比特币交易脚本概述)
  - [比特币交易脚本中常用的指令](#比特币交易脚本中常用的指令)
  - [比特币交易的脚本执行过程(以P2PKH交易为例)](#比特币交易的脚本执行过程(以P2PKH交易为例))
  - [比特币交易的脚本执行流程图(以P2PKH交易为例)](#比特币交易的脚本执行流程图(以P2PKH交易为例))
  

### 比特币交易脚本概述

1. 脚本是区块链上实现自动验证、自动执行合约的重要技术。每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本。
2. 脚本类似一套规则，它约束着接收方怎样花掉这个输出上锁定的资产。它分布运行在区块链网络的每一个节点上。
3. 交易的合法性验证全依赖于交易脚本。
4. 比特币中的脚本机制相对简单，基于堆栈式的解释相关OP指令的引擎。
```
- 基于堆栈的语言的指令只按顺序执行一次，没有循环或跳转指令。是特意设计成图灵不完备的脚本语言。
- 虽然比特币脚本规则不多，不能实现复杂的逻辑。但是它为区块链可编程提供了一个原型，后续的可编程区块链项目是基于脚本的原理发展起来的。
```
5. 比特币脚本语言非常小，只能有256个指令，每个指令一个字节长。这256个指令中75个是保留指令，15个已经废弃。可用的有160多个。

### 比特币交易脚本中常用的指令

指令 | 英文 | 16进制 | 含义
---|---|---|---
OP_DUP | duplicate | 0x76 | 复制栈顶元素
OP_HASH160 | hash | 0xa9 | 弹出栈顶元素，先进行SHA-256哈希，再进行RipeMD160哈希处理，将结果压入栈
OP_EQUALVERIFY | equal verify | 0x88 | 弹出栈顶两个元素，如果两个内容一致，则返回1，脚本继续执行。否则返回0，脚本中断执行
OP_CHECKSIG | check signature | 0xac | 弹出栈顶两个元素，用公钥检查输入中的签名，验证该签名是否是拥有该公钥的用户用其私钥签署的。如果签名符合，则将true(true=1)压人栈顶
OP_CHECKMULTISIG | check multiple signature | 0xae | 用多个公钥检查多重签名的正确性
OP_RETURN | return | 0x6a | 标记交易无效
OP_PUSH | push | 0x4c | 下面多少个字节要被压入堆栈
OP_TRUE/OP_1 |  | 0x51 | 数字1被压入堆栈
OP_FALSE/OP_0 |  | 0x00 | 一个字节空串被压入堆栈

### 比特币交易的脚本执行过程(以P2PKH交易为例)
1. A向B进行转账，该笔交易的输出中包含以下锁定脚本
```
OP_DUP OP_HASH160 <B Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
```
2. B要使用这笔被A转账时锁定的资产，必须在交易输入中有相应的解锁脚本
```
<B Signature><B Public Key>
```
3. 将两个脚本结合形成组合验证脚本
```
先执行输入脚本(解锁脚本)，再执行输出脚本(锁定脚本)，脚本从左至右执行
<B Signature><B Public Key> OP_DUP OP_HASH160 <B Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
```
4. 组合脚本执行过程
```
- 将B的签名sig压入栈顶
- 将B的公钥PubK压入栈顶
- 执行OP_DUP指令，复制栈顶元素(即B的公钥)
- 执行OP_HASH160指令。弹出栈顶元素PubK，先进行SHA-256哈希，再进行RipeMD160哈希处理，将结果PubKHash压入栈
- 将B的公钥hash值压入栈顶，形成新的PubKHash2
- 执行OP_EQUALVERIFY指令。弹出当前栈顶两个元素PubKHash2和PubKHash，判断两者是否一致，如果两者内容一致，则返回1，脚本继续执行。否则返回0，脚本中断执行
- 执行OP_CHECKSIG指令。弹出栈顶当前两个元素sig和PubK，用PubK公钥对sig签名进行校验，验证该签名是否是拥有该公钥的用户用对应的私钥签署的。如果签名符合，则将true(true=1)压入栈顶
```
### 比特币交易的脚本执行流程图(以P2PKH交易为例)
虚拟机通过栈执行，有数据结构基础的可能会理解，栈是一个先入先出的数据结构。虚拟机执行时会先执行输入脚本，再执行输出脚本，如果出错就验证失败。
###### 1. 先入栈sig
stack |
---|
sig |
###### 2. 再入栈pubkey
stack |
---|
pubkey |
sig |
###### 3. 复制栈顶的pubkey
stack |
---|
pubkey |
pubkey |
sig |
###### 4. 做hash160运算
stack |
---|
pubkeyhash |
pubkey |
sig |
###### 5. 入栈PubKeyHash
stack |
---|
pubkeyhash(输出脚本内元素) |
pubkeyhash(输入脚本计算出来) |
pubkey |
sig |
###### 6. 对比栈顶的两个数据是否相等，不相等验证失败
stack |
---|
pubkey |
sig |
###### 7. 取栈顶的pubkey和sig，结合签名数据验证签名，签名验证失败，脚本验证就失败

**注意：虽然输入脚本是先执行，但是按照出现顺序是先有输出脚本，也就是出钱的交易先出来（锁先出来），然后花钱的交易（也就是钥匙）才出来。这里很容易迷糊。**


